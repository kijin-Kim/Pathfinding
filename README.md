# 경로 탐색 시각화 프로그램

C++과 OpenGL로 구현한 실시간 경로 탐색 알고리즘 시각화 도구입니다. 다양한 휴리스틱 방법을 지원하며 대화형 컨트롤과 시각적 피드백을 제공합니다.


## 주요 기능

### 경로 탐색 알고리즘
- **A* 알고리즘**을 다양한 휴리스틱 방법으로 지원:
  - None (다익스트라 알고리즘)
  - Manhattan 거리
  - Euclidean 거리
  - Octile 거리

### 시각화
- 경로 탐색 과정의 실시간 단계별 시각화
- 색상으로 구분되는 노드 상태:
  - **Closed 노드** (청록색): 이미 평가 완료
  - **Open 노드** (진한 청록색): 평가 대기 중
  - **현재 경로** (빨간 선): 현재까지 찾은 최선의 경로
- 격자 기반 맵과 장애물 자동 생성
- 다양한 해상도를 위한 셀 크기 조정

### 인터페이스
- **Start/Pause/Step**: 시뮬레이션 제어
- **Reset**: 맵은 유지하고 경로 탐색 상태만 초기화
- **Rebuild**: 새로운 랜덤 장애물 맵 생성
- **Speed Control**: 시뮬레이션 속도 조정 (0.1배 ~ 5.0배)
- **동적 설정**:
  - 시작/도착 위치 조정
  - 휴리스틱 방법 전환
  - 격자 크기 커스터마이징

## 요구사항

### 의존성 (서브모듈로 포함)
- [CommonCore](https://github.com/kijin-Kim/CommonCore.git): 커스텀 게임 엔진 프레임워크
- GLFW: 윈도우 및 입력 처리
- ImGui: Immediate mode GUI
- GLM: 수학 라이브러리
- Tracy (선택사항): 성능 프로파일링

## 빌드 방법

### 저장소 클론
```bash
git clone --recursive <repository-url>
cd Pathfinding
```

### CMake로 빌드
```bash
mkdir build
cd build
cmake ..
cmake --build . --config Release
```

## 사용법

### 조작법

#### 시뮬레이션 컨트롤
- **Start**: 경로 탐색 시뮬레이션 시작
- **Pause**: 시뮬레이션 일시정지
- **Step**: 한 단계씩 실행 (자동으로 일시정지됨)
- **Speed Slider**: 시뮬레이션 속도 조정

#### 맵 설정
- **Reset**: 경로 탐색 상태 초기화, 현재 맵 유지
- **Rebuild**: 새로운 랜덤 장애물 생성 (30% 벽 밀도)
- **Cell Size**: 격자 셀 크기 조정 (4-64 픽셀)

#### 경로 탐색 설정
- **Start Position**: 시작 행/열 설정
- **End Position**: 목표 행/열 설정
- **Heuristic Method**: 거리 계산 방법 선택

> **참고**: 시작/도착 위치와 휴리스틱 방법은 Reset 또는 Rebuild 후에만 변경 가능합니다.


## 알고리즘 세부사항

### A* 구현
우선순위 큐(최소 힙)를 사용하며 F-cost (G + H)를 우선순위로 사용합니다:
- **G-cost**: 시작 노드로부터의 실제 비용
- **H-cost**: 목표까지의 휴리스틱 추정 비용
- **F-cost**: G + H (총 추정 비용)

### 휴리스틱 방법

#### None (다익스트라)
```cpp
H = 0
```
**특징:**
- 휴리스틱을 사용하지 않음 (H-cost가 항상 0)
- Uniform Cost Search와 동일하게 동작
- 모든 방향을 균등하게 탐색

**장점:**
- 항상 최단 경로를 보장 (admissible)
- 휴리스틱 선택 오류가 없음

**단점:**
- 목표 방향을 고려하지 않아 불필요한 노드를 많이 탐색
- 가장 느린 성능

**사용 시기:**
- 휴리스틱 선택이 어려운 경우
- 최단 경로 보장이 최우선인 경우
- 맵 구조를 모를 때

#### Manhattan 거리
```cpp
H = |Δrow| + |Δcol|
```
**특징:**
- L1 거리 또는 택시캡 거리라고도 함
- 수직/수평 이동만 고려 (대각선 무시)
- 계산이 가장 간단하고 빠름

**장점:**
- 4방향 이동에서 admissible하고 consistent
- 계산 비용이 매우 낮음 (덧셈과 절댓값만 사용)
- 격자 기반 게임에서 널리 사용됨

**단점:**
- 대각선 이동을 허용하는 경우 과대평가(overestimate)
- 과대평가 시 최적 경로를 찾지 못할 수 있음

**사용 시기:**
- 4방향(상하좌우)만 이동 가능한 경우
- 계산 성능이 중요한 경우
- 대각선 이동이 불가능한 게임 (체스의 룩 이동 등)

#### Euclidean 거리
```cpp
H = √(Δrow² + Δcol²)
```
**특징:**
- L2 거리 또는 직선 거리
- 두 점 사이의 실제 기하학적 거리
- 제곱근 연산 필요

**장점:**
- 자유로운 방향 이동에 대해 admissible
- 직관적이고 이해하기 쉬움
- 열린 공간에서 자연스러운 경로 생성

**단점:**
- 격자 제약이 있을 때 과소평가(underestimate)하여 더 많은 노드 탐색
- 제곱근 연산으로 인한 계산 비용 증가
- 8방향 이동에서 최적이 아님

**사용 시기:**
- 모든 방향으로 자유롭게 이동 가능한 경우
- 물리 기반 이동 시스템
- 비격자 기반 경로 탐색

#### Octile 거리
```cpp
H = min(Δrow, Δcol) × √2 + |Δrow - Δcol|
```
또는 다르게 표현하면:
```cpp
H = max(Δrow, Δcol) + (√2 - 1) × min(Δrow, Δcol)
```

**특징:**
- 8방향 이동(대각선 포함)을 위한 최적 휴리스틱
- 대각선 √2 비용과 직교 1.0 비용을 정확히 반영
- Chebyshev 거리의 가중치 버전

**장점:**
- 8방향 이동에 대해 admissible하고 consistent
- Manhattan보다 정확하고 Euclidean보다 효율적
- 대각선 이동 비용을 정확히 고려
- 격자 기반 게임의 표준 휴리스틱

**단점:**
- Manhattan보다 계산이 약간 복잡함
- 4방향만 이동 가능한 경우 과소평가

**사용 시기:**
- 8방향(상하좌우 + 대각선) 이동이 가능한 경우
- 대부분의 격자 기반 게임 (RTS, RPG 등)
- 대각선 이동 비용이 √2인 경우

### 휴리스틱 비교

**4방향 이동만 가능한 경우:**
```
Manhattan > None > Euclidean, Octile
```
- Manhattan이 최적
- Octile과 Euclidean은 과소평가로 비효율적

**8방향 이동 가능한 경우:**
```
Octile > Euclidean > Manhattan > None
```
- Octile이 최적
- Manhattan은 과대평가로 최적 경로 보장 불가

**자유 방향 이동 (물리 기반):**
```
Euclidean > Octile > Manhattan > None
```
- Euclidean이 가장 자연스러움
- 격자 제약이 없으면 Octile의 장점이 사라짐

#### 시각적 차이
프로그램에서 각 휴리스틱을 비교하면 다음을 관찰할 수 있습니다:

**None (다익스트라):**
- 시작점을 중심으로 원형으로 확장
- Open/Closed 노드가 가장 많음
- 모든 방향을 균등하게 탐색

**Manhattan:**
- 마름모 형태로 확장 (4방향 우선)
- 대각선보다 직교 방향을 선호
- 8방향 이동 시 지그재그 경로 생성 가능

**Euclidean:**
- 목표 방향으로 약간 편향된 원형 확장
- Manhattan보다 더 많은 노드 탐색
- 부드러운 경로 생성

**Octile:**
- 목표를 향해 직선적으로 확장
- 가장 적은 노드 탐색 (8방향 기준)
- 대각선을 적극 활용한 효율적 경로

### 코너 컷팅 방지
대각선 이동은 인접한 두 직교 셀이 모두 통과 가능할 때만 허용됩니다:
```cpp
// 위와 왼쪽이 모두 통과 가능할 때만 왼쪽 위 대각선 이동 가능
if (canMoveUp && canMoveLeft) {
    neighbors.push_back(upLeft);
}
```

## 설정

### 경로 탐색 파라미터
`PathfindingConfig.h`에 위치:
```cpp
WALL_DENSITY         = 0.3f    // 30% 장애물
BASE_STEP_INTERVAL   = 0.01f   // 단계당 기본 시간
DIAGONAL_COST        = 1.414f  // √2
ORTHOGONAL_COST      = 1.0f    // 단위 비용
